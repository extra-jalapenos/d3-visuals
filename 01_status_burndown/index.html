<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Burndown Chart</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
	<style>
		html, body {
			margin: 0;
			padding: 0
		}

		body {
			background-color: #ebebeb;
			font-family: Arial, Helvetica, sans-serif;
			font-size: smaller;
		}

	</style>
</head>
<body>
	<script type="module">

	const statusMap = await d3.tsv("../utils/steps.tsv")
	const statusOrder = ["Beginn", "VB I", "Tourenplanung", "VB II", "Termin", "NB I", "NB II", "Fertigstellung", "Prüfung", "Freigabe", "Versand", "Rechnung", "Zahlung"]
	const statusLookup = d3.index(statusMap, d => d.stepName)
	// data needs to be in this directory
	const rawData = await d3.tsv("./data.txt")

	const worklogsByDateAsc = rawData.map(d => {
		const [day, month, year] = d.doneAt.split(" ")[0].split(".").map(digit => Number(digit))
		if (!statusLookup.get(d.workstep)) throw Error("missing workstep " + d.workstep)
		return { referenceYear: Number(d.auditId.slice(0, 4)),
		auditId: d.auditId,
		workstep: statusLookup.get(d.workstep),
		date: new Date(year, month-1, day),
		dateStr: String(new Date(year, month-1, day))}
	}).filter(d => String(new Date(d.dateStr)) !== "Invalid Date")
	.sort((a, b) => a.date - b.date)
	.sort((a, b) => a.referenceYear - b.referenceYear)

	const groupedByReferenceYear = d3.group(worklogsByDateAsc, d => d.referenceYear)

	// great, let's process each referenceYear
	for (const referenceYearBatch of groupedByReferenceYear) {
		const [refYear, rawDataBatch] = referenceYearBatch
		const minDate = d3.min(rawDataBatch, d => d.date)

		// to calculate the progression, we'll need to group by audit
		const sortedWorklogsByAuditId = d3.group(rawDataBatch, d => d.auditId)

		const processLogs = (worklogArray) => {

			// if (worklogArray.length === 1) return []
			const condensed = worklogArray.map(worklog => {
				const { date, workstep } = worklog
				return { date, workstep }
			})

			// make a map of the earliest occurences of all listed steps
			const worklogMap = new d3.rollup(condensed,
				D => d3.min(D.map(d => d.date)),
				d => d.workstep.stepName
			)

			// define hurdles
			const hurdles = [
				"Tourenplanung",
				"VB II",
				"Termin",
				"NB I",
				"Fertigstellung",
				"Prüfung",
				"Freigabe",
				"Versand",
				"Rechnung",
				"Zahlung"
			]

			const hurdleDates = condensed.filter(worklog => hurdles.includes(worklog.workstep.stepName))
			// loop through and increase date if below previous
			let previousDate = null
			const timeline = new d3.InternMap(hurdles.filter(hurdleName => worklogMap.has(hurdleName)) // relevantHurdles in order
				.map(hurdleName => {
					if (worklogMap.get(hurdleName) > previousDate) previousDate = worklogMap.get(hurdleName)
					return [hurdleName, previousDate]
				}))

			// everything else is just contacting the client
			const contactDates = condensed.filter(worklog => hurdles.includes(worklog.workstep.stepName) === false)

			// get VB Is: before Tourenplanung
			const VBIMatches = contactDates.filter(worklog => worklog.date <= worklogMap.get("Tourenplanung"))
			if (VBIMatches.length) {
				timeline.set("VB I", d3.min(VBIMatches, d => d.date))
			}

			// VB I done between set audit date and audit counts as VB II
			const VBIIMatches = contactDates.filter(worklog => worklog.date >= worklogMap.get("Tourenplanung") &&  worklog.date <= worklogMap.get("Termin"))
			if (VBIIMatches.length) {
				const earliestMatch = d3.min(VBIIMatches, d => d.date)
				if (worklogMap.has("VB II")) {
					timeline.set("VB II", d3.min([worklogMap.get("VB II"), earliestMatch]))
				} else {
					timeline.set("VB II", earliestMatch)
				}
			}

			const NBIIMatches = contactDates.filter(worklog => worklog.date >= worklogMap.get("NB I") && worklog.date <= worklogMap.get("Fertigstellung"))
			if (NBIIMatches.length) {
				timeline.set("NB II", d3.min(NBIIMatches, d => d.date))
			}

			// we're not sorting shit, we're frankensteining this together
			const finalArray = 	[
				"VB I",
				"Tourenplanung",
				"VB II",
				"Termin",
				"NB I",
				"NB II",
				"Fertigstellung",
				"Prüfung",
				"Freigabe",
				"Versand",
				"Rechnung",
				"Zahlung"
			].map(stepName => [stepName, timeline.get(stepName)])
			.filter(stepAndDateTuple => !!stepAndDateTuple[1])
			return finalArray
		}

		sortedWorklogsByAuditId.keys().forEach(auditId => {
			const logs = sortedWorklogsByAuditId.get(auditId)
			if (!logs) throw Error(auditId)
			const cleanedLogs = processLogs(logs)
			// now make the whole slew of "+1 -1" etc out of em
			if (logs.length >= 1) {
				let previousStatus = null
				const progression = [["Beginn", minDate], ...cleanedLogs].map(tuple => {
					if (previousStatus === null) {
						previousStatus = tuple[0]
						return { statusName: tuple[0], date: tuple[1], valueChange: 1 }
					}
					const statusChange = [
						{ statusName: previousStatus, date: tuple[1], valueChange: -1 },
						{ statusName: tuple[0], date: tuple[1], valueChange: 1 }
					]
					previousStatus = tuple[0]
					return statusChange
				})

				sortedWorklogsByAuditId.set(auditId, progression.flat())
			}
		})

		// add a running value to each statusId

		// first, group per statusID
		const valueChangePerStatusId = d3.group(Array.from(sortedWorklogsByAuditId.values()).flat(),
			d => d.statusName)

		for (const statusId of valueChangePerStatusId.keys()) {
			const entriesInStatus = valueChangePerStatusId.get(statusId)

			let valueProgression = 0
			const valueChangePerDay = d3.rollups(entriesInStatus, D => d3.sum(D.map(d => d.valueChange)), d => d.date)
				// console.log(Array.from(valueChangePerDay.keys())
				.sort((D1, D2) => D1[0] - D2[0])
				.map(D => {
					const change = D[1]
					valueProgression += change
					return [ D[0], { date: D[0], status: statusId, value: change, valueProgression }]
				})

			valueChangePerStatusId.set(statusId, valueChangePerDay)
		}

		const lastKnownState = new d3.InternMap(statusOrder.map(key => [key, { value: 0, valueProgression: 0 }]))
		const byDate = d3.rollups(Array.from(valueChangePerStatusId.values()).flat().map(D => D[1]).sort((a, b) => a.date - b.date), D => new d3.InternMap(D.map(d => [d.status, d])), d => d.date)

		for (const dateStack of byDate) {
			const [dateKey, InternMap] = dateStack
			// add empty values
			let dayStackSum = 0
			statusOrder.forEach(status => {
				if (InternMap.has(status) === false) {
					InternMap.set(status, { status, date: dateKey, value: 0, valueProgression: lastKnownState.get(status).valueProgression })
				} else {
				lastKnownState.set(status, { ...InternMap.get(status) })
				}

				// stacking!
				const currentVal = InternMap.get(status)
				InternMap.set(status, { ...currentVal, stackStart: dayStackSum, stackEnd: dayStackSum + currentVal.valueProgression })
				dayStackSum += currentVal.valueProgression
			})

			dateStack[1] = Array.from(InternMap.values())
		}

		groupedByReferenceYear[1] = byDate
	}

	const height = document.documentElement.clientHeight / 3
	const width = document.documentElement.clientWidth
	const svg = d3.select("body")
		.append("svg")
		.attr("width", "100%")
		.attr("height", "100%")
		.attr("viewBox", `0, 0, ${width}, ${height}`)
		.attr("preserveAspectRatio", "none")

	const margin = { left: 50, top: 10, bottom: 20, right: 10 }
	const canvasses = svg
		.selectAll("g.canvas")
		.data(groupedByReferenceYear.get(2022))
		.enter()
		.append("g")
		.attr("class", "canvas")
		.attr("name", d => d[0])
		.attr("transform", (d, i) => `translate(${margin.left}, ${margin.top + i * height})`)

	const axes = canvasses.append("g").attr("class", "axes")

	axes.each(function (datum) {

		const xScale = d3.scaleTime()
			.domain([new Date(datum[0], 0, 1), new Date(datum[0] + 1, 5, 30)])
			.range([0, width - margin.left - margin.right])

		xScale.clamp(true)

		const yScale = d3.scaleLinear()
			.domain([0, datum.size])
			.range([height - margin.bottom, 0])
			.nice()

		axes
			.append("g")
			.attr("class", datum => "x axis " + datum[0])
			.attr("transform", `translate(${margin.left}, ${height + margin.top - margin.bottom})`)
			.call(d3.axisBottom(xScale))


		axes
			.append("g")
			.attr("class", datum => "y axis " + datum[0])
			.attr("transform", `translate(${margin.left}, ${margin.top})`)
			.call(d3.axisLeft(yScale))
	})

	const colorScaleAlt = d3.scaleSequential(d3.interpolateRdYlGn).domain([0, statusOrder.length])
	const areaGenerator = d3.area(d => xScale(d.date), d => yScale(d.stackStart), d => yScale(d.stackEnd))

	const plots = canvasses.selectAll("path").data(d3.group(byDate.map(D => D[1]).flat(), d => d.status))
			.enter()
			.append("path")
			.attr("class", "plot")
			.attr("id", (d) => d)
			.attr("id", (d, i) => i)
			.attr("fill", (d, i) => d3.color(colorScaleAlt(i)).formatHex()+"ee")
			.attr("stroke", (d, i) => colorScaleAlt(i))
			.attr("d", d => areaGenerator(d[1]))

	// adding markers for relevant lines
	const relevantDates = [
		new Date(refYear, 6, 31), // Meilenstein 1 Ende Juli
		new Date(refYear+1, 0, 1), // Neujahr
		new Date(refYear+1, 0, 15), // Bayernwerk-Abrechnungen
		new Date(refYear+1, 1, 28) // Frist
	]
	const markerGroup = svg
		.append("g")
		.attr("class", "relevant-dates")
		.attr("transform", `translate(${margin.left}, ${margin.top})`)

	const markerGenerator = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y))
	const markers = markerGroup.selectAll("g").data(relevantDates)
									.enter()
									.append("g")
									.attr("id", d => d.toLocaleDateString("de-DE"))
									.append("path")
									.attr("class", "markerLine")
									.attr("stroke", "black")
									.attr("d", d => markerGenerator([{ x: d, y: yScale.domain()[0] }, { x: d, y: yScale.domain()[1] }]))

	const legend = svg.append("g").attr("class", "legend").attr("transform", `translate(${margin.left}, ${height + margin.top - margin.bottom + 20 })`)

	const entries = legend.selectAll("g")
	.data(statusOrder)
	.enter()
	.append("g")
	.attr("name", d => d)

	const colorBoxSize = 7
	const colorBoxes = entries
		.append("rect")
		.attr("fill", (d, i) => colorScaleAlt(i))
		.attr("height", colorBoxSize)
		.attr("width", colorBoxSize)
		.attr("y", (d, i) => i * colorBoxSize*1.5)
		.attr("x", 0)

	const text = entries
		.append("text")
		.attr("fill", "black")
		.attr("text-anchor", "start")
		.text(d => d)
		.attr("y", (d, i) => (i + 0.75) * colorBoxSize*1.5)
		.attr("x", 15)
	</script>
</body>
</html>
