<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Audit Duedates</title>
	<link rel="stylesheet" href="base.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
</head>
<body>
<script type="module">
	// for FULL view!
	const width = document.documentElement.clientWidth
	const height = document.documentElement.clientHeight

	const body = d3.select("body")
		// .append("svg")
		.attr("width", width)
		.attr("height", height)
		.attr("viewBox", `0, 0, ${width}, ${height}`)
		.attr("preserveAspectRatio", "none")

	const worklogDataRaw = await d3.tsv("./worklogs.txt")
	const auditDataRaw = await d3.tsv("./audits.txt")
	const stepsRaw = await d3.tsv("../01_status_burndown/steps.tsv")
	const steps = d3.index(stepsRaw.map(d => {
		return { ...d, id: Number(d.id), stageId: Number(d.stageId), Punkte: parseFloat(d.Punkte) }
	}), d => d.stepName)
	// because my data is so old i'm gonna pretend that "TODAY" is the 10th of Feb 2024
	const today = new Date(2024, 1, 10)

	const auditFactData = auditDataRaw.map(d => {
			const [day, month, year] = d.dueDateAudit.split(" ")[0].split(".")
			return {
				auditId: d.auditId,
				progress: steps.get(d.progressLabel),
				dueDate: new Date(year, month-1, day)
			}
		})

	const auditFactMap = d3.index(auditFactData, d => d.auditId)
	// only keep awsv / vaws and specific steps
	const worklogDataFiltered = worklogDataRaw
		.filter(d => d.auditId.includes("_awsv") || d.auditId.includes("_vaws") || d.auditId.includes("_betrSichV"))
		.filter(d => ["Termin", "Freigabe", "Versand"].includes(d.workstep))
		.map(d => {
			const [day, month, year] = d.doneAt.split(" ")[0].split(".")
			return {
				...d,
				workstep: steps.get(d.workstep),
				doneAt: new Date(year, month-1, day)
			}
		})

	const rangeOfAudits = d3.extent(worklogDataFiltered.filter(d => d.workstep.stepName === "Termin"), d => d.doneAt)

	// create a map by audit
	const auditEvaluationMap = d3.group(worklogDataFiltered, d => d.auditId)

	// for each map process the content so we get { "done": true, "daysBetweenAudit": 23, "auditDate": Date, "auditor": Name }
	for (const audit of auditEvaluationMap) {
		const [auditId, data] = audit
		const rollupMap = d3.rollup(data, D => d3.min(D.map(d => d.doneAt)), d => d.workstep.stepName)
		// due date etc. lookup:
		const auditFacts = auditFactMap.get(auditId)
		// as long as progress is above 11 done is true
		const status = auditFacts.progress
		const category = () => {
			if (!rollupMap.get("Termin")) return "To Do"
			if (!rollupMap.get("Versand")) return "Finalized"
			return "Done"
		}

		const processTime = () => {
			const start = rollupMap.get("Termin")
			// if we don't know the sendoff date we'll settle for finalization
			const end = rollupMap.get("Versand") || rollupMap.get("Freigabe") || today
			if (!start) return null
			const differenceInDays = (
				Date.UTC(end.getUTCFullYear(), end.getUTCMonth(), end.getUTCDate())
				- Date.UTC(start.getUTCFullYear(), start.getUTCMonth(), start.getUTCDate())
			) / (1000 * 86400)
			return differenceInDays
		}

		const differenceInDays = processTime()
		const calculateProcessTimeCategory = () => {
			if (differenceInDays === null || differenceInDays < 0) return "unknown"
			if (differenceInDays > 8*7) return "> 8 Wochen"
			const timeBordersInWeeks = [ 1, 2, 3, 4, 5, 6, 7, 8 ]
			const numWeeks = timeBordersInWeeks.findLast(weekNum => weekNum *7 <= differenceInDays)
			if (!numWeeks) return "unknown"
			return `${numWeeks} Woche${numWeeks >= 1 ? "n" : ""}`
		}

		auditEvaluationMap.set(auditId, {
			progress: auditFacts.progress,
			category: category(),
			differenceInDays,
			processTimeGroup: calculateProcessTimeCategory(),
			audit: rollupMap.get("Termin"),
			dueDate: auditFacts.dueDate
		})

	}

	const auditDateRange = d3.extent(auditEvaluationMap.values(), d => d.audit)
	const months = d3.timeMonth.every(1).range(...auditDateRange)

	const grouped = d3.group(Array.from(auditEvaluationMap.values()),
		d => d.audit?.getFullYear())

	const plotHeight = height / 3
	const margins = { top: 10, bottom: 30, left: 50, right: 20 }
	const yearPlots = d3.select("body").selectAll("svg")
		.data(grouped)
		.enter()
		.append("svg")
		.attr("height", plotHeight)
		.attr("width", width)
		.attr("class", "plot")
		.attr("id", d => d[0])

	yearPlots.each(function (datum) {
		const currentGroup = d3.select(this)
		const canvas = currentGroup
			.append("g")
			.attr("class", "canvas")
			.attr("width", width - margins.left - margins.right)
			.attr("height", plotHeight - margins.bottom - margins.top)
			.attr("transform", `translate(${margins.left}, ${margins.top})`)

		const axesGroup = currentGroup.append("g")
			.attr("class", "axes")
			.attr("height", plotHeight - margins.bottom - margins.top)

		const xAxis = axesGroup.append("g")
			.attr("class", "x axis")
			.attr("transform", `translate(${margins.left}, ${plotHeight - margins.bottom})`)

		const yAxis = axesGroup.append("g")
			.attr("class", "y axis")
			.attr("transform", `translate(${margins.left}, ${margins.top})`)

		const [refYear, dataBatch] = datum
		const calendarYear = [new Date(refYear, 0, 1), new Date(refYear, 11, 31)]
		const monthStartArray = d3.timeMonth.every(1).range(...calendarYear)
		.map(date => date.toLocaleDateString(undefined, { month: "short" }))
		const xScale = d3.scaleBand(monthStartArray, [0, width - margins.left - margins.right])
		xScale.padding(0.1)


		const yScale = d3.scaleLinear().domain([50, 0]).range([0, plotHeight - margins.bottom - margins.top])

		xAxis.call(d3.axisBottom(xScale))
		yAxis.call(d3.axisLeft(yScale))


		const groupedByMonths = d3.group(dataBatch, d => d.audit?.toLocaleDateString(undefined, { month: "short" }))

		const orderOfGroups = [
			"1 Woche",	"2 Wochen",	"3 Wochen",	"4 Wochen",	"5 Wochen",	"6 Wochen",	"7 Wochen",	"8 Wochen",	">8 Wochen"
		]
		const colorScale = d3.scaleOrdinal([...orderOfGroups].reverse(), d3.schemeRdYlBu[9])

		for (const monthGroup of groupedByMonths) {
			const [month, data] = monthGroup
			const summed = d3.rollup(data, D => D.length, d => d.processTimeGroup)

			const currentState = { start: 0, end: 0 }
			const valueArray = []
			orderOfGroups.forEach(groupName => {
				if (summed.has(groupName)) {
					const value = summed.get(groupName)
					currentState.end += value
					valueArray.push({ group: groupName, value, ...currentState, monthName: month })
					currentState.start += value
				}
			})
			groupedByMonths.set(month, valueArray)
		}

		const flatArray = Array.from(groupedByMonths.values()).flat()
		// ok now let's do the series
		const series = d3.index(flatArray, d => d.group, d => d.monthName)
		const group = canvas.selectAll("g")
			.data(series)
			.enter()
			.append("g")
			.attr("class", d => d[0])

		console.log(yScale(0))
		group.each(function (serie) {
			d3.select(this)
				.selectAll("rect")
				.data(serie[1])
				.enter()
				.append("rect")
				.attr("fill", colorScale(serie[0]))
				.attr("value", d => d[1].value)
				.attr("x", d => xScale(d[0]))
				.attr("y", d => yScale(d[1].end))
				.attr("width", d => xScale.bandwidth())
				.attr("height", d => yScale(d[1].start) - yScale(d[1].end))
		})
	})

</script>
</body>
</html>
