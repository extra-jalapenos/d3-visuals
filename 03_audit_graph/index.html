<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Visual Timeline of audits</title>
	<link rel="stylesheet" href="base.css">
</head>
<body>
<script type="module">
	import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

	const worklogDataRaw = await d3.tsv("../01_status_burndown/data.txt")
	const auditDataRaw = await d3.tsv("../02_audit_duedates/audits.txt")
	const stepsRaw = await d3.tsv("../01_status_burndown/steps.tsv")
	const steps = d3.index(stepsRaw.map(d => {
		return { ...d, id: Number(d.id), stageId: Number(d.stageId), Punkte: parseFloat(d.Punkte) }
	}), d => d.stepName)

	// which timeframe should be shown
	const timeFrameShown = [new Date(2023,10,1), new Date(2024, 1, 5)]
	// we save the generators for e.g. ticks by strings for accessing them and dynamically generating the x-Axis
	const hierarchyLevels = new d3.InternMap([["year", d3.timeYear.every(1)],  [ "quarter", d3.timeMonth.every(3) ], [ "month", d3.timeMonth ]])

	let chosenHierarchyLevel = "month"

	const worklogDataFiltered = worklogDataRaw
		.map(d => {
			// invalid date?
			const [day, month, year] = d.doneAt.split(" ")[0].split(".")
			const dateObj = new Date(year, month-1, day)
			if (isNaN(dateObj.getTime())) return null

			return {
				...d,
				workstep: steps.get(d.workstep),
				doneAt: new Date(year, month-1, day)
			}
		})
		.filter(el => el !== null)

	const worklogsInTimeframe = worklogDataFiltered.filter(d => d.doneAt >= timeFrameShown[0] && d.doneAt <= timeFrameShown[1])
	const auditIdsWithWorklogsInTimeframe = d3.union(worklogsInTimeframe.map(d => d.auditId))

	// create a map by audit
	const auditEvaluationMap = d3.group(worklogDataFiltered, d => d.auditId)

	// color scale
	const statusOrder = ["Beginn", "VB I", "Tourenplanung", "VB II", "Termin", "NB I", "NB II", "Fertigstellung", "PrÃ¼fung", "Freigabe", "Versand", "Rechnung", "Zahlung"]
	const colorScale = d3.scaleSequential(d3.interpolateRdYlGn).domain([0, statusOrder.length])

	// preprocess the loaded data
	const auditFactData = auditDataRaw.map(d => {
			const [day, month, year] = d.dueDateAudit.split(" ")[0].split(".")
			return {
				auditId: d.auditId,
				progress: steps.get(d.progressLabel),
				dueDate: new Date(year, month-1, day)
			}
		})

	const auditFactMap = d3.index(auditFactData, d => d.auditId)


	// Declare the chart dimensions and margins.
	const width = document.documentElement.clientWidth;
	const marginTop = 20;
	const marginRight = 40;
	const marginBottom = 50;
	const marginLeft = 250;
	const laneHeight = 20
	const height = marginTop + marginBottom + laneHeight * auditIdsWithWorklogsInTimeframe.size;

	// Create the SVG container.
	const svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height)
			.attr("viewBox", `0, 0, ${width}, ${height}`)
			.attr("preserveAspectRatio", "none")

	// Declare the x (horizontal position) scale.
	const x = d3.scaleUtc()
			.domain(timeFrameShown)
			.range([marginLeft, width - marginRight]);

	// Declare the y (vertical position) scale.
	const y = d3.scaleBand()
			.domain(auditIdsWithWorklogsInTimeframe)
			.range([height - marginBottom, marginTop]);

	// Add the x-axis.
	const xAxis = svg.append("g")
			.attr("transform", `translate(0,${height - marginBottom})`)
			.call(d3.axisBottom(x)
				.ticks(hierarchyLevels.get(chosenHierarchyLevel))
				.tickFormat(d3.utcFormat("%d.%m.%y"))
			)

	// Add the y-axis.
	svg.append("g")
			.attr("transform", `translate(${marginLeft},0)`)
			.call(d3.axisLeft(y));
</script>
</body>
</html>
