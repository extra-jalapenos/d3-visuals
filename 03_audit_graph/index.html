<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Visual Timeline of audits</title>
	<link rel="stylesheet" href="base.css">
</head>
<body>
<script type="module">
	import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

	const worklogDataRaw = await d3.tsv("../01_status_burndown/data.txt")
	const auditDataRaw = await d3.tsv("../02_audit_duedates/audits.txt")
	const stepsRaw = await d3.tsv("../01_status_burndown/steps.tsv")
	const steps = d3.index(stepsRaw.map(d => {
		return { ...d, id: Number(d.id), stageId: Number(d.stageId), Punkte: parseFloat(d.Punkte) }
	}), d => d.stepName)

	// which timeframe should be shown
	const timeFrameShown = [new Date(2023,10,1), new Date(2024, 1, 5)]
	// we save the generators for e.g. ticks by strings for accessing them and dynamically generating the x-Axis
	const hierarchyLevels = new d3.InternMap([["year", d3.timeYear.every(1)],  [ "quarter", d3.timeMonth.every(3) ], [ "month", d3.timeMonth ]])

	let chosenHierarchyLevel = "month"

	const worklogDataFiltered = worklogDataRaw
		.map(d => {
			// invalid date?
			const [day, month, year] = d.doneAt.split(" ")[0].split(".")
			const dateObj = new Date(year, month-1, day)
			if (isNaN(dateObj.getTime())) return null
			return {
				...d,
				workstep: steps.get(d.workstep),
				doneAt: new Date(year, month-1, day)
			}
		})
		.filter(el => el !== null)

	const worklogsInTimeframe = worklogDataFiltered.filter(d => d.doneAt >= timeFrameShown[0] && d.doneAt <= timeFrameShown[1])
	const auditEvaluationMap = d3.group(worklogDataFiltered, d => d.auditId)

	// create a map by audit

	// color scale
	const statusOrder = ["Beginn", "VB I", "Tourenplanung", "VB II", "Termin", "NB I", "NB II", "Fertigstellung", "PrÃ¼fung", "Freigabe", "Versand", "Rechnung", "Zahlung"]
	const colorScale = d3.scaleSequential(d3.interpolateRdYlGn).domain([0, statusOrder.length])

	// preprocess the loaded data
	const auditFactData = auditDataRaw.map(d => {
			const [day, month, year] = d.dueDateAudit.split(" ")[0].split(".")
			if (steps.has(d.progressLabel) === false) throw Error(d.progressLabel)
			return {
				auditId: d.auditId,
				progress: steps.get(d.progressLabel),
				dueDate: new Date(year, month-1, day)
			}
		})
	const auditFactMap = d3.index(auditFactData, d => d.auditId)

	// collect relevant info such as progress, dueDate, last activity by ID
	const auditIdsWithWorklogsInTimeframe = d3.sort(d3.union(worklogsInTimeframe.map(d => d.auditId)), (a, b) => {
		const statusA = auditFactMap.has(a) ? auditFactMap.get(a).progress.id : 0
		const statusB = auditFactMap.has(b) ? auditFactMap.get(b).progress.id : 0
		return d3.ascending(a, b)
	})

	// Declare the chart dimensions and margins.
	const width = document.documentElement.clientWidth;
	const marginTop = 20;
	const marginRight = 100;
	const marginBottom = 50;
	const marginLeft = 250;
	const laneHeight = 20
	const height = marginTop + marginBottom + laneHeight * auditIdsWithWorklogsInTimeframe.length;

	// Create the SVG container.
	const svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height)
			.attr("viewBox", `0, 0, ${width}, ${height}`)
			.attr("preserveAspectRatio", "none")

	// a canvas!
	const canvas = svg.append("g")
		.attr("class", "canvas")
		.attr("height", height - marginTop - marginBottom)
		.attr("width", width - marginLeft - marginRight)
		.attr("transform", `translate(${marginLeft}, ${marginTop})`)

	// Declare the x (horizontal position) scale.
	const xScale = d3.scaleUtc()
			.domain(timeFrameShown)
			.range([0, width - marginLeft - marginRight]);

	// Declare the y (vertical position) scale.
	const yScale = d3.scaleBand()
			.domain(auditIdsWithWorklogsInTimeframe)
			.range([height - marginBottom, marginTop]);

	// Add the x-axis.
	const xAxis = svg.append("g")
			.attr("class", "x axis")
			.attr("transform", `translate(${marginLeft},${height - marginBottom})`)
			.call(d3.axisBottom(xScale)
				.ticks(hierarchyLevels.get(chosenHierarchyLevel))
				.tickFormat(d3.utcFormat("%d.%m.%y"))
			)

	// Add the y-axis.
	const yAxis =	svg.append("g")
			.attr("class", "y axis")
			.attr("transform", `translate(${marginLeft},0)`)
			.call(d3.axisLeft(yScale));

	// adding a group for each audit with match in timeframe
	const auditDataPointGroups = canvas.selectAll("g")
		.data(auditIdsWithWorklogsInTimeframe)
		.enter()
		.append("g")
		.attr("id", d => d)

	const circleRadius = yScale.bandwidth()

	auditDataPointGroups.each(function (auditId, index) {
		const dataPoints = auditEvaluationMap.get(auditId)
		const dataPointsInTimeframe = dataPoints.filter(d => d.doneAt >= timeFrameShown[0] && d.doneAt <= timeFrameShown[1])
		const currentGroup = d3.select(this)
		const status = auditFactMap.has(auditId) ? auditFactMap.get(auditId) : "unknown"
		currentGroup
			.append("text")
			.text(status.progress ? status.progress.stepName : "Beginn")
			.attr("x", width - marginLeft - marginRight + 10)
			.attr("y", yScale(auditId) - laneHeight/4)
			.attr("textBaseline", "middle")

		currentGroup.append("rect")
			.attr("width", width - marginLeft - marginRight)
			.attr("height", yScale.bandwidth() * 0.7)
			.attr("class", "lane")
			.attr("y", yScale(auditId) - (yScale.bandwidth() * 0.85))

		currentGroup.selectAll("circle")
			.data(dataPointsInTimeframe)
			.enter()
			.append("circle")
			.attr("date", d => d.doneAt)
			.attr("cx", d => xScale(d.doneAt))
			.attr("cy", yScale(auditId) - laneHeight / 2)
			.attr("r", 4)
			.attr("fill", d => colorScale(d.workstep.id))
			.attr("stroke", d => colorScale(d.workstep.id))
	})
	</script>
</body>
</html>
